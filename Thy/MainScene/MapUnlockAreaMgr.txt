---@type CameraShownViewPosType
local CameraShownViewPosType = util.relativeRequire("CameraShownViewPosType")
local table_insert = table.insert
local table_sort = table.stable_sort
local math_abs = math.abs

---地图解锁区域管理类
---@class mapUnlockAreaMgr
local mapUnlockAreaMgr = Class()

---@class DoMoveReturn
---@field canMove boolean 是否可以移动
---@field cameraPosX number 相机x坐标
---@field cameraPosY number 相机y坐标

---@class DoZoomingReturn
---@field canZooming boolean 是否可以缩放
---@field orthographicSize number 相机视野一半高度
---@field needRefreshPos boolean 是否刷新相机位置
---@field cameraPosX number 相机x坐标
---@field cameraPosY number 相机y坐标

---@class CameraShownViewPosData 相机视野坐标数据
---@field isAllPosInside boolean 相机视野四个边界的坐标是否都在解锁区域内
---@field outsidePosDataList CameraOutsidePosData[] 相机视野超出范围的坐标数据列表

---@class CameraOutsidePosData 相机视野超出范围的坐标数据
---@field posType number
---@field deltaMinX number
---@field deltaMinY number
---@field sort number

---@class MapUnlockAreaMgrParams
---@field cameraZoomCoefficient number
---@field initCameraSize number
---@field cameraMinZoom number
---@field cameraMaxZoom number
---@field tileWidthCount number
---@field tileHeightCount number
---@field centerTileX number
---@field centerTileY number
---@field tileWidthPixles number
---@field freeMove boolean
---@field go_SceneRoot UnityEngine.GameObject
---@field sceneCamera UnityEngine.Camera
---@field gizmos_camera GizmosUtil

---@param mgr mapUnlockAreaMgr
---@param param MapUnlockAreaMgrParams
---@private
function mapUnlockAreaMgr.ctor(mgr, param)
    -- 缓存上下左右四个点的数据
    ---@type UnityEngine.Vector2
    mgr.leftTopPos = {}
    ---@type UnityEngine.Vector2
    mgr.rightTopPos = {}
    ---@type UnityEngine.Vector2
    mgr.leftBottomPos = {}
    ---@type UnityEngine.Vector2
    mgr.rightBottomPos = {}
    -- 缓存上下左右四个点超出去的坐标的数据
    ---@type CameraShownViewPosData
    mgr.cameraShownViewPosData = {}
    ---@type CameraOutsidePosData
    mgr.cameraLeftTopOutsidePosData = {}
    ---@type CameraOutsidePosData
    mgr.cameraRightTopOutsidePosData = {}
    ---@type CameraOutsidePosData
    mgr.cameraLeftBottomOutsidePosData = {}
    ---@type CameraOutsidePosData
    mgr.cameraRightBottomOutsidePosData = {}

    -- 相机移动结果
    ---@type DoMoveReturn
    mgr.doMoveReturn = {}
    -- 相机缩放结果
    ---@type DoZoomingReturn
    mgr.doZoomingReturn = {}
    -- 屏幕边框四个顶点的数据
    ---@type number[]
    mgr.cameraPosLimitList = {}
    ---屏幕数据
    local safeAreaWidth, safeAreaHeight = SafeAreaUtil.GetSafeAreaSize()
    ---@type number[]
    mgr.screenData = { safeAreaWidth, safeAreaHeight }
    ---已解锁区域的边界数据
    ---@type AreaLimitData
    mgr.areaLimitDataForUnlock = {}

    -- 一些配置或者预设的数值
    ---@type CameraShownViewPosType
    mgr.PosType = CameraShownViewPosType
    mgr.maxValue = 100000000
    mgr.extendCameraShownView = ConfigMap.param["mainMapPixel"].value
    mgr.cameraZoomCoefficient = param.cameraZoomCoefficient
    mgr.initCameraSize = param.initCameraSize
    mgr.cameraMinZoom = param.cameraMinZoom
    mgr.cameraMaxZoom = param.cameraMaxZoom
    mgr.tileWidthCount = param.tileWidthCount
    mgr.tileHeightCount = param.tileHeightCount
    mgr.centerTileX = param.centerTileX
    mgr.centerTileY = param.centerTileY
    mgr.tileWidthPixles = param.tileWidthPixles
    mgr.freeMove = param.freeMove
    mgr.go_SceneRoot = param.go_SceneRoot
    mgr.sceneCamera = param.sceneCamera
    mgr.gizmos_camera = param.gizmos_camera
    mgr.tilePixles2Unit = param.tileWidthPixles / 100
    mgr.halfTilePixles2Unit = mgr.tilePixles2Unit / 2
end

---初始化
function mapUnlockAreaMgr:Init()
    self:InitData()
    self:SetMapPosLimit()
    self:GetUnlockAreaLimitData()
    self:AddListener()
end

---释放
function mapUnlockAreaMgr:Shut()
    self:RemoveListener()
    self:DestroyAreaLineGizmos()
end

---获取相机视野范围
---@return number[]
function mapUnlockAreaMgr:GetCameraShownView()
    -- minX
    self.cameraPosLimitList[1] = self.cameraPosX - self.halfCameraWidthSize
    -- maxX
    self.cameraPosLimitList[2] = self.cameraPosX + self.halfCameraWidthSize
    -- minY
    self.cameraPosLimitList[3] = self.cameraPosY - self.orthographicSize
    -- maxY
    self.cameraPosLimitList[4] = self.cameraPosY + self.orthographicSize
    return self.cameraPosLimitList
end

---获取已解锁的区域内最小的x坐标
---@return number, number
function mapUnlockAreaMgr:GetUnlockAreaMinPosX()
    local minPosX = self.areaLimitDataForUnlock and self.areaLimitDataForUnlock.minWorldPosX or 0
    return minPosX, self.halfCameraWidthSize
end

---判断相机坐标是否是有效的
---@param worldPos UnityEngine.Vector3
---@return boolean
function mapUnlockAreaMgr:IsPosValid(worldPos)
    ---@type UnityEngine.Vector3
    local targetPos = { x = worldPos.x, y = worldPos.y, z = worldPos.z }
    local minPosX = targetPos.x - self.halfCameraWidthSize
    local maxPosX = targetPos.x + self.halfCameraWidthSize
    local minPosY = targetPos.y - self.orthographicSize
    local maxPosY = targetPos.y + self.orthographicSize
    ---@type CameraShownViewPosData
    local data = self:IsCameraViewPosInUnlockArea(minPosX, maxPosX, minPosY, maxPosY, true)
    return data.isAllPosInside
end

---获取修正后的可以移动到的目标位置
---@param worldPos UnityEngine.Vector3
---@return UnityEngine.Vector3
function mapUnlockAreaMgr:GetTargetPosForMove(worldPos)
    ---@type UnityEngine.Vector3
    local targetPos = { x = worldPos.x, y = worldPos.y, z = worldPos.z }
    local minPosX = targetPos.x - self.halfCameraWidthSize
    local maxPosX = targetPos.x + self.halfCameraWidthSize
    local minPosY = targetPos.y - self.orthographicSize
    local maxPosY = targetPos.y + self.orthographicSize
    ---@type CameraShownViewPosData
    local data = self:IsCameraViewPosInUnlockArea(minPosX, maxPosX, minPosY, maxPosY, true)
    -- 全都在视野范围内，可以移动
    if data.isAllPosInside == true then
        return targetPos
    end

    -- 如果超过解锁区域，则要尝试移动回解锁区域
    local dataList = self.cameraShownViewPosData.outsidePosDataList

    -- 没有数据表示不可移动
    if #dataList <= 0 then
        return nil
    end

    table_sort(dataList, function(xData, yData)
        return xData.sort < yData.sort
    end)

    local tempCameraPosX = 0
    local tempCameraPosY = 0

    for i = 1, #dataList do
        local data = dataList[i]
        if data.posType == self.PosType.LeftTop then
            -- 左上角超出解锁区域
            tempCameraPosX = targetPos.x + data.deltaMinX
            tempCameraPosY = targetPos.y - data.deltaMinY
        elseif data.posType == self.PosType.RightTop then
            -- 右上角超出解锁区域
            tempCameraPosX = targetPos.x - data.deltaMinX
            tempCameraPosY = targetPos.y - data.deltaMinY
        elseif data.posType == self.PosType.LeftBottom then
            -- 左下角超出解锁区域
            tempCameraPosX = targetPos.x + data.deltaMinX
            tempCameraPosY = targetPos.y + data.deltaMinY
        else
            -- 右下角超出解锁区域
            tempCameraPosX = targetPos.x - data.deltaMinX
            tempCameraPosY = targetPos.y + data.deltaMinY
        end

        minPosX = tempCameraPosX - self.halfCameraWidthSize
        maxPosX = tempCameraPosX + self.halfCameraWidthSize
        minPosY = tempCameraPosY - self.orthographicSize
        maxPosY = tempCameraPosY + self.orthographicSize

        local cameraShownViewPosData = self:IsCameraViewPosInUnlockArea(minPosX, maxPosX, minPosY, maxPosY, false)
        -- 移动后相机视野全部在解锁区域内，则找到最近的可以移动的点
        if cameraShownViewPosData.isAllPosInside == true then
            targetPos.x = tempCameraPosX
            targetPos.y = tempCameraPosY
            return targetPos
        end
    end
    return nil
end

---自动移动相机方法结束后要重置相机位置
---@param pos UnityEngine.Vector3
function mapUnlockAreaMgr:SetCameraPos(pos)
    self.cameraPosX = pos.x
    self.cameraPosY = pos.y
end

---获取当前相机位置
---@return number, number
function mapUnlockAreaMgr:GetCameraPos()
    return self.cameraPosX, self.cameraPosY
end

---获取相机视野大小
---@return number
function mapUnlockAreaMgr:GetCameraSize()
    return self.orthographicSize
end

---重置相机视野（被导演系统修改后的相机视野，要重置回正确的数据）
---@param size number
function mapUnlockAreaMgr:ResetCameraSize(size)
    self.orthographicSize = size
    self.halfCameraWidthSize = (self.screenData[1] * self.orthographicSize) / self.screenData[2]
end

---获取相机边界数据
---@return number, number, number, number
function mapUnlockAreaMgr:GetMapPosLimit()
    return self.mapMinPosX, self.mapMaxPosX, self.mapMinPosY, self.mapMaxPosY
end

---获取已解锁的地图边界数据
---@return number, number, number, number
function mapUnlockAreaMgr:GetMapPosLimitByAreaUnlock()
    local minWorldPosX = self.areaLimitDataForUnlock and self.areaLimitDataForUnlock.minWorldPosX or -100
    local maxWorldPosX = self.areaLimitDataForUnlock and self.areaLimitDataForUnlock.maxWorldPosX or 100
    local minWorldPosY = self.areaLimitDataForUnlock and self.areaLimitDataForUnlock.minWorldPosY or -100
    local maxWorldPosY = self.areaLimitDataForUnlock and self.areaLimitDataForUnlock.maxWorldPosY or 100
    return minWorldPosX, maxWorldPosX, minWorldPosY, maxWorldPosY
end

---移动逻辑判断
---@param deltaX number
---@param deltaY number
---@param isAmble boolean 是否是缓行
---@return DoMoveReturn
function mapUnlockAreaMgr:DoMove(deltaX, deltaY, isAmble)
    local tempCameraPosX = self.cameraPosX - deltaX
    local tempCameraPosY = self.cameraPosY - deltaY

    -- 区域判断
    local tempMinMapPosX = tempCameraPosX - self.halfCameraWidthSize
    local tempMaxMapPosX = tempCameraPosX + self.halfCameraWidthSize
    local tempMinMapPosY = tempCameraPosY - self.orthographicSize
    local tempMaxMapPosY = tempCameraPosY + self.orthographicSize

    -- 判断xy是否都能移动
    local cameraShownViewPosData = self:IsCameraViewPosInUnlockArea(tempMinMapPosX, tempMaxMapPosX, tempMinMapPosY,
        tempMaxMapPosY, false)
    if cameraShownViewPosData.isAllPosInside == false then
        if isAmble then
            self.doMoveReturn.canMove = false
            return self.doMoveReturn
        end

        -- 判断x是否可以移动
        tempCameraPosX = self.cameraPosX - deltaX
        tempCameraPosY = self.cameraPosY
        tempMinMapPosX = tempCameraPosX - self.halfCameraWidthSize
        tempMaxMapPosX = tempCameraPosX + self.halfCameraWidthSize
        tempMinMapPosY = tempCameraPosY - self.orthographicSize
        tempMaxMapPosY = tempCameraPosY + self.orthographicSize
        cameraShownViewPosData = self:IsCameraViewPosInUnlockArea(tempMinMapPosX, tempMaxMapPosX, tempMinMapPosY,
            tempMaxMapPosY, false)
        if cameraShownViewPosData.isAllPosInside == true then
            self.cameraPosX = tempCameraPosX
            self.cameraPosY = tempCameraPosY
            self.doMoveReturn.cameraPosX = tempCameraPosX
            self.doMoveReturn.cameraPosY = tempCameraPosY
            self.doMoveReturn.canMove = true
            return self.doMoveReturn
        end

        -- 判断y是否可以移动
        tempCameraPosX = self.cameraPosX
        tempCameraPosY = self.cameraPosY - deltaY
        tempMinMapPosX = tempCameraPosX - self.halfCameraWidthSize
        tempMaxMapPosX = tempCameraPosX + self.halfCameraWidthSize
        tempMinMapPosY = tempCameraPosY - self.orthographicSize
        tempMaxMapPosY = tempCameraPosY + self.orthographicSize
        cameraShownViewPosData = self:IsCameraViewPosInUnlockArea(tempMinMapPosX, tempMaxMapPosX, tempMinMapPosY,
            tempMaxMapPosY, false)
        if cameraShownViewPosData.isAllPosInside == true then
            self.cameraPosX = tempCameraPosX
            self.cameraPosY = tempCameraPosY
            self.doMoveReturn.cameraPosX = tempCameraPosX
            self.doMoveReturn.cameraPosY = tempCameraPosY
            self.doMoveReturn.canMove = true
            return self.doMoveReturn
        end

        self.doMoveReturn.canMove = false
        return self.doMoveReturn
    end

    -- 地图边界判断
    if tempMinMapPosX < self.mapMinPosX then
        tempCameraPosX = self.mapMinPosX + self.halfCameraWidthSize
    elseif tempMaxMapPosX > self.mapMaxPosX then
        tempCameraPosX = self.mapMaxPosX - self.halfCameraWidthSize
    end
    if tempMinMapPosY < self.mapMinPosY then
        tempCameraPosY = self.mapMinPosY + self.orthographicSize
    elseif tempMaxMapPosY > self.mapMaxPosY then
        tempCameraPosY = self.mapMaxPosY - self.orthographicSize
    end

    self.cameraPosX = tempCameraPosX
    self.cameraPosY = tempCameraPosY

    -- 返回值构建
    self.doMoveReturn.canMove = true
    self.doMoveReturn.cameraPosX = self.cameraPosX
    self.doMoveReturn.cameraPosY = self.cameraPosY
    return self.doMoveReturn
end

---缩放逻辑判断
---@param delta System.Single 缩放差值
---@return DoZoomingReturn
function mapUnlockAreaMgr:DoZooming(delta)
    -- 改变相机视口大小
    local tempOrthographicSize = self.orthographicSize - delta * self.cameraZoomCoefficient
    if tempOrthographicSize > self.cameraMaxZoom then
        tempOrthographicSize = self.cameraMaxZoom
    elseif tempOrthographicSize < self.cameraMinZoom then
        tempOrthographicSize = self.cameraMinZoom
    end

    local tempHalfCameraWidthSize = (self.screenData[1] * tempOrthographicSize) / self.screenData[2]

    -- 区域判断
    local tempMinMapPosX = self.cameraPosX - tempHalfCameraWidthSize
    local tempMaxMapPosX = self.cameraPosX + tempHalfCameraWidthSize
    local tempMinMapPosY = self.cameraPosY - tempOrthographicSize
    local tempMaxMapPosY = self.cameraPosY + tempOrthographicSize

    local cameraShownViewPosData = self:IsCameraViewPosInUnlockArea(tempMinMapPosX, tempMaxMapPosX, tempMinMapPosY,
        tempMaxMapPosY, true)
    -- 缩放后的视野全部都在解锁区域内，表示可以进行缩放
    if cameraShownViewPosData.isAllPosInside == true then
        self.orthographicSize = tempOrthographicSize
        self.halfCameraWidthSize = tempHalfCameraWidthSize
        self:ShowCameraGizmos()
        self.doZoomingReturn.canZooming = true
        self.doZoomingReturn.orthographicSize = self.orthographicSize
        self.doZoomingReturn.needRefreshPos = false
        return self.doZoomingReturn
    end

    -- 如果缩放后有超过解锁区域，则要尝试移动回解锁区域
    local dataList = cameraShownViewPosData.outsidePosDataList

    -- 没有数据表示不可缩放
    if #dataList <= 0 then
        self.doZoomingReturn.canZooming = false
        return self.doZoomingReturn
    end

    local tempCameraPosX = 0
    local tempCameraPosY = 0
    table_sort(dataList, function(xData, yData)
        return xData.sort < yData.sort
    end)

    for i = 1, #dataList do
        local data = dataList[i]
        if data.posType == self.PosType.LeftTop then
            -- 左上角超出解锁区域
            tempCameraPosX = self.cameraPosX + data.deltaMinX
            tempCameraPosY = self.cameraPosY - data.deltaMinY
        elseif data.posType == self.PosType.RightTop then
            -- 右上角超出解锁区域
            tempCameraPosX = self.cameraPosX - data.deltaMinX
            tempCameraPosY = self.cameraPosY - data.deltaMinY
        elseif data.posType == self.PosType.LeftBottom then
            -- 左下角超出解锁区域
            tempCameraPosX = self.cameraPosX + data.deltaMinX
            tempCameraPosY = self.cameraPosY + data.deltaMinY
        else
            -- 右下角超出解锁区域
            tempCameraPosX = self.cameraPosX - data.deltaMinX
            tempCameraPosY = self.cameraPosY + data.deltaMinY
        end

        tempMinMapPosX = tempCameraPosX - tempHalfCameraWidthSize
        tempMaxMapPosX = tempCameraPosX + tempHalfCameraWidthSize
        tempMinMapPosY = tempCameraPosY - tempOrthographicSize
        tempMaxMapPosY = tempCameraPosY + tempOrthographicSize

        local cameraShownViewPosData = self:IsCameraViewPosInUnlockArea(tempMinMapPosX, tempMaxMapPosX, tempMinMapPosY,
            tempMaxMapPosY, false)
        -- 移动后相机视野全部在解锁区域内，则返回可以缩放且需要移动
        if cameraShownViewPosData.isAllPosInside == true then
            self.cameraPosX = tempCameraPosX
            self.cameraPosY = tempCameraPosY
            self.orthographicSize = tempOrthographicSize
            self.halfCameraWidthSize = tempHalfCameraWidthSize
            self:ShowCameraGizmos()
            self.doZoomingReturn.canZooming = true
            self.doZoomingReturn.orthographicSize = self.orthographicSize
            self.doZoomingReturn.needRefreshPos = true
            self.doZoomingReturn.cameraPosX = self.cameraPosX
            self.doZoomingReturn.cameraPosY = self.cameraPosY
            return self.doZoomingReturn
        end
    end

    self.doZoomingReturn.canZooming = false
    return self.doZoomingReturn
end

---初始化数据
---@private
function mapUnlockAreaMgr:InitData()
    self.cameraPosX = self.sceneCamera.transform.localPosition.x
    self.cameraPosY = self.sceneCamera.transform.localPosition.y
    self.orthographicSize = self.sceneCamera.orthographicSize
    self.halfCameraWidthSize = (self.screenData[1] * self.orthographicSize) / self.screenData[2]
end

---刷新相机边界数据
---@private
function mapUnlockAreaMgr:SetMapPosLimit()
    -- 刷新整个地图的边界
    self.mapMinPosX = -(self.centerTileX * self.tilePixles2Unit + self.halfTilePixles2Unit)
    self.mapMinPosX = self.mapMinPosX + 2.56
    self.mapMaxPosX = (self.tileWidthCount - 1 - self.centerTileX) * self.tilePixles2Unit + self.halfTilePixles2Unit
    self.mapMaxPosX = self.mapMaxPosX - 2.56
    self.mapMinPosY = -((self.tileHeightCount - 1 - self.centerTileY) * self.tilePixles2Unit + self.halfTilePixles2Unit)
    self.mapMinPosY = self.mapMinPosY + 10.24
    self.mapMaxPosY = self.centerTileY * self.tilePixles2Unit + self.halfTilePixles2Unit
end

---获取解锁了的区域边界数据
---@private
function mapUnlockAreaMgr:GetUnlockAreaLimitData()
    local allAreaLimitData = ModelFactory.TileMap:GetAllAreaLimitData()
    -- 根据不同场景获取不同的解锁区域
    local unlockAreaList = ModelFactory.VillageScene:GetVillageArea()

    ---@type AreaLimitData
    local limitData = {}
    limitData.maxWorldPosX = -self.maxValue
    limitData.minWorldPosX = self.maxValue
    limitData.maxWorldPosY = -self.maxValue
    limitData.minWorldPosY = self.maxValue

    for _, areaData in ipairs(unlockAreaList) do
        -- 开垦完成
        if self.freeMove or areaData.status == VillageAreaStatus.ReclamationEnd then
            local areaLimitData = allAreaLimitData[areaData.cId]
            local tempMaxCameraPosX = areaLimitData.maxWorldPosX + self.extendCameraShownView
            local tempMinCameraPosX = areaLimitData.minWorldPosX - self.extendCameraShownView
            local tempMaxCameraPosY = areaLimitData.maxWorldPosY + self.extendCameraShownView
            local tempMinCameraPosY = areaLimitData.minWorldPosY - self.extendCameraShownView
            -- 地图边界限制
            tempMaxCameraPosX = tempMaxCameraPosX > self.mapMaxPosX and self.mapMaxPosX or tempMaxCameraPosX
            tempMinCameraPosX = tempMinCameraPosX < self.mapMinPosX and self.mapMinPosX or tempMinCameraPosX
            tempMaxCameraPosY = tempMaxCameraPosY > self.mapMaxPosY and self.mapMaxPosY or tempMaxCameraPosY
            tempMinCameraPosY = tempMinCameraPosY < self.mapMinPosY and self.mapMinPosY or tempMinCameraPosY
            -- 边界范围为所有区域的四个角构成的矩形
            limitData.maxWorldPosX = limitData.maxWorldPosX < tempMaxCameraPosX and tempMaxCameraPosX or
                limitData.maxWorldPosX
            limitData.minWorldPosX = limitData.minWorldPosX > tempMinCameraPosX and tempMinCameraPosX or
                limitData.minWorldPosX
            limitData.maxWorldPosY = limitData.maxWorldPosY < tempMaxCameraPosY and tempMaxCameraPosY or
                limitData.maxWorldPosY
            limitData.minWorldPosY = limitData.minWorldPosY > tempMinCameraPosY and tempMinCameraPosY or
                limitData.minWorldPosY
        end
    end

    self.areaLimitDataForUnlock = limitData
end

---判断相机视野的四个点是否都在解锁区域内 【左上点、左下点、右上点、右下点】
---@param tempMinMapPosX number
---@param tempMaxMapPosX number
---@param tempMinMapPosY number
---@param tempMaxMapPosY number
---@param needOutsidePosData boolean 是否需要计算超出范围的坐标 【移动逻辑不需要】
---@return CameraShownViewPosData
---@private
function mapUnlockAreaMgr:IsCameraViewPosInUnlockArea(
    tempMinMapPosX, tempMaxMapPosX, tempMinMapPosY, tempMaxMapPosY, needOutsidePosData)

    -- 相机视野四个边界的点
    self.leftTopPos.x = tempMinMapPosX
    self.leftTopPos.y = tempMaxMapPosY
    self.rightTopPos.x = tempMaxMapPosX
    self.rightTopPos.y = tempMaxMapPosY
    self.leftBottomPos.x = tempMinMapPosX
    self.leftBottomPos.y = tempMinMapPosY
    self.rightBottomPos.x = tempMaxMapPosX
    self.rightBottomPos.y = tempMinMapPosY

    -- 相机视野区域要全都在解锁区域内才能移动
    local leftTopPosInside = false
    local rightTopPosInside = false
    local leftBottomPosInside = false
    local rightBottomPosInside = false

    -- 如果有个相机视野坐标超出了解锁区域，则计算到解锁区域的最小路径
    -- 左上点要移入的最小x、y坐标
    local leftTopDeltaMinX = self.maxValue
    local leftTopDeltaMinY = self.maxValue
    -- 右上点要移入的最小x、y坐标
    local rightTopDeltaMinX = self.maxValue
    local rightTopDeltaMinY = self.maxValue
    -- 左下点要移入的最小x、y坐标
    local leftBottomDeltaMinX = self.maxValue
    local leftBottomDeltaMinY = self.maxValue
    -- 右下点要移入的最小x、y坐标
    local rightBottomDeltaMinX = self.maxValue
    local rightBottomDeltaMinY = self.maxValue

    -- 相机视野区域要都在解锁区域内
    local areaData = self.areaLimitDataForUnlock
    -- 相机视野左上点判断是否超出区域
    local leftTopPosMinXInside = areaData.minWorldPosX <= self.leftTopPos.x
    local leftTopPosMaxXInside = self.leftTopPos.x <= areaData.maxWorldPosX
    local leftTopPosMinYInside = areaData.minWorldPosY <= self.leftTopPos.y
    local leftTopPosMaxYInside = self.leftTopPos.y <= areaData.maxWorldPosY

    -- 重新校正，避免浮点数误差
    if leftTopPosMinXInside == false then
        local tempX = areaData.minWorldPosX - self.leftTopPos.x
        tempX = math_abs(tempX)
        if tempX < 0.0000001 then
            leftTopPosMinXInside = true
        end
    end
    if leftTopPosMaxXInside == false then
        local tempX = self.leftTopPos.x - areaData.maxWorldPosX
        tempX = math_abs(tempX)
        if tempX < 0.0000001 then
            leftTopPosMaxXInside = true
        end
    end
    if leftTopPosMinYInside == false then
        local tempY = areaData.minWorldPosY - self.leftTopPos.y
        tempY = math_abs(tempY)
        if tempY < 0.0000001 then
            leftTopPosMinYInside = true
        end
    end
    if leftTopPosMaxYInside == false then
        local tempY = self.leftTopPos.y - areaData.maxWorldPosY
        tempY = math_abs(tempY)
        if tempY < 0.0000001 then
            leftTopPosMaxYInside = true
        end
    end

    -- 左上角的点在解锁区域内
    if leftTopPosMinXInside == true and leftTopPosMaxXInside == true and leftTopPosMinYInside == true and
        leftTopPosMaxYInside == true then
        leftTopPosInside = true
        leftTopDeltaMinX = 0
        leftTopDeltaMinY = 0
    else
        if needOutsidePosData == false then
            goto continue
        end

        local tempDeltaMinX = self.maxValue
        local tempDeltaMinY = self.maxValue
        -- 判断左上点的x是否在解锁区域内
        if leftTopPosMinXInside == true and leftTopPosMaxXInside == true then
            tempDeltaMinX = 0
        else
            -- 左上点最左边超出了区域
            if leftTopPosMinXInside == false then
                local deltaX = areaData.minWorldPosX - self.leftTopPos.x
                tempDeltaMinX = tempDeltaMinX < deltaX and tempDeltaMinX or deltaX
            end

            -- 左上点最右边超出了区域
            if leftTopPosMaxXInside == false then
                local deltaX = self.leftTopPos.x - areaData.maxWorldPosX
                tempDeltaMinX = tempDeltaMinX < deltaX and tempDeltaMinX or deltaX
            end
        end

        -- 判断左上点的y是否在解锁区域内
        if leftTopPosMinYInside == true and leftTopPosMaxYInside == true then
            tempDeltaMinY = 0
        else
            -- 左上点最下边超出了区域
            if leftTopPosMinYInside == false then
                local deltaY = areaData.minWorldPosY - self.leftTopPos.y
                tempDeltaMinY = tempDeltaMinY < deltaY and tempDeltaMinY or deltaY
            end

            -- 左上点最上边超出了区域
            if leftTopPosMaxYInside == false then
                local deltaY = self.leftTopPos.y - areaData.maxWorldPosY
                tempDeltaMinY = tempDeltaMinY < deltaY and tempDeltaMinY or deltaY
            end
        end

        -- x和y的移动值加起来小的表示移入所需的最短距离
        local curDelta = tempDeltaMinX + tempDeltaMinY
        local delta = leftTopDeltaMinX + leftTopDeltaMinY
        if curDelta < delta then
            leftTopDeltaMinX = tempDeltaMinX
            leftTopDeltaMinY = tempDeltaMinY
        end
        ::continue::
    end

    -- 相机视野右上点判断是否超出区域
    local rightTopPosMinXInside = areaData.minWorldPosX <= self.rightTopPos.x
    local rightTopPosMaxXInside = self.rightTopPos.x <= areaData.maxWorldPosX
    local rightTopPosMinYInside = areaData.minWorldPosY <= self.rightTopPos.y
    local rightTopPosMaxYInside = self.rightTopPos.y <= areaData.maxWorldPosY

    -- 重新校正，避免浮点数误差
    if rightTopPosMinXInside == false then
        local tempX = areaData.minWorldPosX - self.rightTopPos.x
        tempX = math_abs(tempX)
        if tempX < 0.0000001 then
            rightTopPosMinXInside = true
        end
    end
    if rightTopPosMaxXInside == false then
        local tempX = self.rightTopPos.x - areaData.maxWorldPosX
        tempX = math_abs(tempX)
        if tempX < 0.0000001 then
            rightTopPosMaxXInside = true
        end
    end
    if rightTopPosMinYInside == false then
        local tempY = areaData.minWorldPosY - self.rightTopPos.y
        tempY = math_abs(tempY)
        if tempY < 0.0000001 then
            rightTopPosMinYInside = true
        end
    end
    if rightTopPosMaxYInside == false then
        local tempY = self.rightTopPos.y - areaData.maxWorldPosY
        tempY = math_abs(tempY)
        if tempY < 0.0000001 then
            rightTopPosMaxYInside = true
        end
    end

    -- 右上角的点在解锁区域内
    if rightTopPosMinXInside == true and rightTopPosMaxXInside == true and rightTopPosMinYInside == true and
        rightTopPosMaxYInside == true then
        rightTopPosInside = true
        rightTopDeltaMinX = 0
        rightTopDeltaMinY = 0
    else
        if needOutsidePosData == false then
            goto continue
        end

        local tempDeltaMinX = self.maxValue
        local tempDeltaMinY = self.maxValue
        -- 判断右上点的x是否在解锁区域内
        if rightTopPosMinXInside == true and rightTopPosMaxXInside == true then
            tempDeltaMinX = 0
        else
            -- 右上点最左边超出了区域
            if rightTopPosMinXInside == false then
                local deltaX = areaData.minWorldPosX - self.rightTopPos.x
                tempDeltaMinX = tempDeltaMinX < deltaX and tempDeltaMinX or deltaX
            end

            -- 右上点最右边超出了区域
            if rightTopPosMaxXInside == false then
                local deltaX = self.rightTopPos.x - areaData.maxWorldPosX
                tempDeltaMinX = tempDeltaMinX < deltaX and tempDeltaMinX or deltaX
            end
        end

        -- 判断右上点的y是否在解锁区域内
        if rightTopPosMinYInside == true and rightTopPosMaxYInside == true then
            tempDeltaMinY = 0
        else
            -- 右上点最下边超出了区域
            if rightTopPosMinYInside == false then
                local deltaY = areaData.minWorldPosY - self.rightTopPos.y
                tempDeltaMinY = tempDeltaMinY < deltaY and tempDeltaMinY or deltaY
            end

            -- 右上点最上边超出了区域
            if rightTopPosMaxYInside == false then
                local deltaY = self.rightTopPos.y - areaData.maxWorldPosY
                tempDeltaMinY = tempDeltaMinY < deltaY and tempDeltaMinY or deltaY
            end
        end

        -- x和y的移动值加起来小的表示移入所需的最短距离
        local curDelta = tempDeltaMinX + tempDeltaMinY
        local delta = rightTopDeltaMinX + rightTopDeltaMinY
        if curDelta < delta then
            rightTopDeltaMinX = tempDeltaMinX
            rightTopDeltaMinY = tempDeltaMinY
        end
        ::continue::
    end

    -- 相机视野左下点判断是否超出区域
    local leftBottomPosMinXInside = areaData.minWorldPosX <= self.leftBottomPos.x
    local leftBottomPosMaxXInside = self.leftBottomPos.x <= areaData.maxWorldPosX
    local leftBottomPosMinYInside = areaData.minWorldPosY <= self.leftBottomPos.y
    local leftBottomPosMaxYInside = self.leftBottomPos.y <= areaData.maxWorldPosY

    -- 重新校正，避免浮点数误差
    if leftBottomPosMinXInside == false then
        local tempX = areaData.minWorldPosX - self.leftBottomPos.x
        tempX = math_abs(tempX)
        if tempX < 0.0000001 then
            leftBottomPosMinXInside = true
        end
    end
    if leftBottomPosMaxXInside == false then
        local tempX = self.leftBottomPos.x - areaData.maxWorldPosX
        tempX = math_abs(tempX)
        if tempX < 0.0000001 then
            leftBottomPosMaxXInside = true
        end
    end
    if leftBottomPosMinYInside == false then
        local tempY = areaData.minWorldPosY - self.leftBottomPos.y
        tempY = math_abs(tempY)
        if tempY < 0.0000001 then
            leftBottomPosMinYInside = true
        end
    end
    if leftBottomPosMaxYInside == false then
        local tempY = self.leftBottomPos.y - areaData.maxWorldPosY
        tempY = math_abs(tempY)
        if tempY < 0.0000001 then
            leftBottomPosMaxYInside = true
        end
    end

    -- 左下角的点在解锁区域内
    if leftBottomPosMinXInside == true and leftBottomPosMaxXInside == true and leftBottomPosMinYInside == true and
        leftBottomPosMaxYInside == true then
        leftBottomPosInside = true
        leftBottomDeltaMinX = 0
        leftBottomDeltaMinY = 0
    else
        if needOutsidePosData == false then
            goto continue
        end

        local tempDeltaMinX = self.maxValue
        local tempDeltaMinY = self.maxValue
        -- 判断左下点的x是否在解锁区域内
        if leftBottomPosMinXInside == true and leftBottomPosMaxXInside == true then
            tempDeltaMinX = 0
        else
            -- 左下点最左边超出了区域
            if leftBottomPosMinXInside == false then
                local deltaX = areaData.minWorldPosX - self.leftBottomPos.x
                tempDeltaMinX = tempDeltaMinX < deltaX and tempDeltaMinX or deltaX
            end

            -- 左下点最右边超出了区域
            if leftBottomPosMaxXInside == false then
                local deltaX = self.leftBottomPos.x - areaData.maxWorldPosX
                tempDeltaMinX = tempDeltaMinX < deltaX and tempDeltaMinX or deltaX
            end
        end

        -- 判断左下点的y是否在解锁区域内
        if leftBottomPosMinYInside == true and leftBottomPosMaxYInside == true then
            tempDeltaMinY = 0
        else
            -- 左下点最下边超出了区域
            if leftBottomPosMinYInside == false then
                local deltaY = areaData.minWorldPosY - self.leftBottomPos.y
                tempDeltaMinY = tempDeltaMinY < deltaY and tempDeltaMinY or deltaY
            end

            -- 左下点最上边超出了区域
            if leftBottomPosMaxYInside == false then
                local deltaY = self.leftBottomPos.y - areaData.maxWorldPosY
                tempDeltaMinY = tempDeltaMinY < deltaY and tempDeltaMinY or deltaY
            end
        end

        -- x和y的移动值加起来小的表示移入所需的最短距离
        local curDelta = tempDeltaMinX + tempDeltaMinY
        local delta = leftBottomDeltaMinX + leftBottomDeltaMinY
        if curDelta < delta then
            leftBottomDeltaMinX = tempDeltaMinX
            leftBottomDeltaMinY = tempDeltaMinY
        end
        ::continue::
    end

    -- 相机视野右下点判断是否超出区域
    local rightBottomPosMinXInside = areaData.minWorldPosX <= self.rightBottomPos.x
    local rightBottomPosMaxXInside = self.rightBottomPos.x <= areaData.maxWorldPosX
    local rightBottomPosMinYInside = areaData.minWorldPosY <= self.rightBottomPos.y
    local rightBottomPosMaxYInside = self.rightBottomPos.y <= areaData.maxWorldPosY

    -- 重新校正，避免浮点数误差
    if rightBottomPosMinXInside == false then
        local tempX = areaData.minWorldPosX - self.rightBottomPos.x
        tempX = math_abs(tempX)
        if tempX < 0.0000001 then
            rightBottomPosMinXInside = true
        end
    end
    if rightBottomPosMaxXInside == false then
        local tempX = self.rightBottomPos.x - areaData.maxWorldPosX
        tempX = math_abs(tempX)
        if tempX < 0.0000001 then
            rightBottomPosMaxXInside = true
        end
    end
    if rightBottomPosMinYInside == false then
        local tempY = areaData.minWorldPosY - self.rightBottomPos.y
        tempY = math_abs(tempY)
        if tempY < 0.0000001 then
            rightBottomPosMinYInside = true
        end
    end
    if rightBottomPosMaxYInside == false then
        local tempY = self.rightBottomPos.y - areaData.maxWorldPosY
        tempY = math_abs(tempY)
        if tempY < 0.0000001 then
            rightBottomPosMaxYInside = true
        end
    end

    -- 右下角的点在解锁区域内
    if rightBottomPosMinXInside == true and rightBottomPosMaxXInside == true and rightBottomPosMinYInside == true and
        rightBottomPosMaxYInside == true then
        rightBottomPosInside = true
        rightBottomDeltaMinX = 0
        rightBottomDeltaMinY = 0
    else
        if needOutsidePosData == false then
            goto continue
        end

        local tempDeltaMinX = self.maxValue
        local tempDeltaMinY = self.maxValue
        -- 判断右下点的x是否在解锁区域内
        if rightBottomPosMinXInside == true and rightBottomPosMaxXInside == true then
            tempDeltaMinX = 0
        else
            -- 右下点最左边超出了区域
            if rightBottomPosMinXInside == false then
                local deltaX = areaData.minWorldPosX - self.rightBottomPos.x
                tempDeltaMinX = tempDeltaMinX < deltaX and tempDeltaMinX or deltaX
            end

            -- 右下点最右边超出了区域
            if rightBottomPosMaxXInside == false then
                local deltaX = self.rightBottomPos.x - areaData.maxWorldPosX
                tempDeltaMinX = tempDeltaMinX < deltaX and tempDeltaMinX or deltaX
            end
        end

        -- 判断右下点的y是否在解锁区域内
        if rightBottomPosMinYInside == true and rightBottomPosMaxYInside == true then
            tempDeltaMinY = 0
        else
            -- 右下点最下边超出了区域
            if rightBottomPosMinYInside == false then
                local deltaY = areaData.minWorldPosY - self.rightBottomPos.y
                tempDeltaMinY = tempDeltaMinY < deltaY and tempDeltaMinY or deltaY
            end

            -- 右下点最上边超出了区域
            if rightBottomPosMaxYInside == false then
                local deltaY = self.rightBottomPos.y - areaData.maxWorldPosY
                tempDeltaMinY = tempDeltaMinY < deltaY and tempDeltaMinY or deltaY
            end
        end

        -- x和y的移动值加起来小的表示移入所需的最短距离
        local curDelta = tempDeltaMinX + tempDeltaMinY
        local delta = rightBottomDeltaMinX + rightBottomDeltaMinY
        if curDelta < delta then
            rightBottomDeltaMinX = tempDeltaMinX
            rightBottomDeltaMinY = tempDeltaMinY
        end
        ::continue::
    end

    -- 相机视野四个边界的坐标都在解锁区域内
    if leftTopPosInside == true and rightTopPosInside == true and leftBottomPosInside == true and
        rightBottomPosInside == true then
        self.cameraShownViewPosData.isAllPosInside = true
        return self.cameraShownViewPosData
    end

    -- 不需要计算相机视野超出解锁区域的点 【移动逻辑不关心】
    if needOutsidePosData == false then
        self.cameraShownViewPosData.isAllPosInside = false
        return self.cameraShownViewPosData
    end

    self.cameraShownViewPosData.isAllPosInside = false
    self.cameraShownViewPosData.outsidePosDataList = {}

    -- 左上角的坐标超了解锁区域
    if leftTopPosInside == false then
        leftTopDeltaMinX = leftTopDeltaMinX == self.maxValue and 0 or leftTopDeltaMinX
        leftTopDeltaMinY = leftTopDeltaMinY == self.maxValue and 0 or leftTopDeltaMinY
        self.cameraLeftTopOutsidePosData.posType = self.PosType.LeftTop
        self.cameraLeftTopOutsidePosData.deltaMinX = leftTopDeltaMinX
        self.cameraLeftTopOutsidePosData.deltaMinY = leftTopDeltaMinY
        self.cameraLeftTopOutsidePosData.sort = leftTopDeltaMinX + leftTopDeltaMinY
        table_insert(self.cameraShownViewPosData.outsidePosDataList, self.cameraLeftTopOutsidePosData)
    end

    -- 右上角的坐标超了解锁区域
    if rightTopPosInside == false then
        rightTopDeltaMinX = rightTopDeltaMinX == self.maxValue and 0 or rightTopDeltaMinX
        rightTopDeltaMinY = rightTopDeltaMinY == self.maxValue and 0 or rightTopDeltaMinY
        self.cameraRightTopOutsidePosData.posType = self.PosType.RightTop
        self.cameraRightTopOutsidePosData.deltaMinX = rightTopDeltaMinX
        self.cameraRightTopOutsidePosData.deltaMinY = rightTopDeltaMinY
        self.cameraRightTopOutsidePosData.sort = rightTopDeltaMinX + rightTopDeltaMinY
        table_insert(self.cameraShownViewPosData.outsidePosDataList, self.cameraRightTopOutsidePosData)
    end

    -- 左下角的坐标超了解锁区域
    if leftBottomPosInside == false then
        leftBottomDeltaMinX = leftBottomDeltaMinX == self.maxValue and 0 or leftBottomDeltaMinX
        leftBottomDeltaMinY = leftBottomDeltaMinY == self.maxValue and 0 or leftBottomDeltaMinY
        self.cameraLeftBottomOutsidePosData.posType = self.PosType.LeftBottom
        self.cameraLeftBottomOutsidePosData.deltaMinX = leftBottomDeltaMinX
        self.cameraLeftBottomOutsidePosData.deltaMinY = leftBottomDeltaMinY
        self.cameraLeftBottomOutsidePosData.sort = leftBottomDeltaMinX + leftBottomDeltaMinY
        table_insert(self.cameraShownViewPosData.outsidePosDataList, self.cameraLeftBottomOutsidePosData)
    end

    -- 右下角的坐标超了解锁区域
    if rightBottomPosInside == false then
        rightBottomDeltaMinX = rightBottomDeltaMinX == self.maxValue and 0 or rightBottomDeltaMinX
        rightBottomDeltaMinY = rightBottomDeltaMinY == self.maxValue and 0 or rightBottomDeltaMinY
        self.cameraRightBottomOutsidePosData.posType = self.PosType.RightBottom
        self.cameraRightBottomOutsidePosData.deltaMinX = rightBottomDeltaMinX
        self.cameraRightBottomOutsidePosData.deltaMinY = rightBottomDeltaMinY
        self.cameraRightBottomOutsidePosData.sort = rightBottomDeltaMinX + rightBottomDeltaMinY
        table_insert(self.cameraShownViewPosData.outsidePosDataList, self.cameraRightBottomOutsidePosData)
    end
    return self.cameraShownViewPosData
end

---添加监听
---@private
function mapUnlockAreaMgr:AddListener()
    if ModelFactory.VillageScene:IsMine() == true then
        self.areaChangeCallback = Local.Village.areas:OnChange(function()
            self:GetUnlockAreaLimitData()
            self:ShowAreaLineGizmos()
        end)
    end
end

---移除监听
---@private
function mapUnlockAreaMgr:RemoveListener()
    if self.areaChangeCallback then
        self.areaChangeCallback()
        self.areaChangeCallback = nil
    end
end

---销毁画线工具
---@private
function mapUnlockAreaMgr:DestroyAreaLineGizmos()
    if not util.isNull(self.MapGizmosView) then
        GameObject.Destroy(self.MapGizmosView.gameObject)
        self.MapGizmosView = nil
    end
end

---显示相机视野范围
---@private
function mapUnlockAreaMgr:ShowCameraGizmos()
    if util.isNull(self.MapGizmosView) then
        return
    end

    local isShow = CS.SROptionsData.IsShowTileMapEnable()
    -- 显示
    if isShow == true then
        self.MapGizmosView:ChangeCameraBox(self.gizmos_camera, self.orthographicSize * 2, self.halfCameraWidthSize * 2)
        self.MapGizmosView:SetCameraLine(self.gizmos_camera, self.mapMinPosX, self.mapMaxPosX, self.mapMinPosY,
            self.mapMaxPosY)
        return
    end

    -- 隐藏
    self.MapGizmosView:ChangeCameraBox(self.gizmos_camera, 0, 0)
    self.MapGizmosView:SetCameraLine(self.gizmos_camera, 0, 0, 0, 0)
end

---显示区域边界
---@private
function mapUnlockAreaMgr:ShowAreaLineGizmos()
    if util.isNull(self.MapGizmosView) then
        return
    end

    local allAreaLimitData = ModelFactory.TileMap:GetAllAreaLimitData()
    -- 根据不同场景获取不同的解锁区域
    local unlockAreaList = ModelFactory.VillageScene:GetVillageArea()

    ---@type AreaLimitData
    local limitData = { maxWorldPosX = -self.maxValue, minWorldPosX = self.maxValue, maxWorldPosY = -self.maxValue,
        minWorldPosY = self.maxValue }

    for i = 1, #unlockAreaList do
        local areaData = unlockAreaList[i]
        -- 开垦完成
        if areaData.status == VillageAreaStatus.ReclamationEnd then
            local areaLimitData = allAreaLimitData[areaData.cId]
            self.MapGizmosView:SetAreaLine(i, areaLimitData.minWorldPosX, areaLimitData.maxWorldPosX,
                areaLimitData.minWorldPosY, areaLimitData.maxWorldPosY)
            local tempMaxCameraPosX = areaLimitData.maxWorldPosX + self.extendCameraShownView
            local tempMinCameraPosX = areaLimitData.minWorldPosX - self.extendCameraShownView
            local tempMaxCameraPosY = areaLimitData.maxWorldPosY + self.extendCameraShownView
            local tempMinCameraPosY = areaLimitData.minWorldPosY - self.extendCameraShownView
            -- 地图边界限制
            tempMaxCameraPosX = tempMaxCameraPosX > self.mapMaxPosX and self.mapMaxPosX or tempMaxCameraPosX
            tempMinCameraPosX = tempMinCameraPosX < self.mapMinPosX and self.mapMinPosX or tempMinCameraPosX
            tempMaxCameraPosY = tempMaxCameraPosY > self.mapMaxPosY and self.mapMaxPosY or tempMaxCameraPosY
            tempMinCameraPosY = tempMinCameraPosY < self.mapMinPosY and self.mapMinPosY or tempMinCameraPosY
            ---@type AreaLimitData
            local data = { maxWorldPosX = tempMaxCameraPosX, minWorldPosX = tempMinCameraPosX,
                maxWorldPosY = tempMaxCameraPosY, minWorldPosY = tempMinCameraPosY }
            self.MapGizmosView:SetAreaLine(100 + i, data.minWorldPosX, data.maxWorldPosX, data.minWorldPosY,
                data.maxWorldPosY)
            -- 边界范围为所有区域的四个角构成的矩形
            limitData.maxWorldPosX = limitData.maxWorldPosX < tempMaxCameraPosX and tempMaxCameraPosX or
                limitData.maxWorldPosX
            limitData.minWorldPosX = limitData.minWorldPosX > tempMinCameraPosX and tempMinCameraPosX or
                limitData.minWorldPosX
            limitData.maxWorldPosY = limitData.maxWorldPosY < tempMaxCameraPosY and tempMaxCameraPosY or
                limitData.maxWorldPosY
            limitData.minWorldPosY = limitData.minWorldPosY > tempMinCameraPosY and tempMinCameraPosY or
                limitData.minWorldPosY
        end
    end

    self.MapGizmosView:SetAreaLine(10000, limitData.minWorldPosX, limitData.maxWorldPosX, limitData.minWorldPosY,
        limitData.maxWorldPosY)
end

---显示画线工具
---@param isShow boolean
function mapUnlockAreaMgr:ShowMapGizmos(isShow)
    -- 加载
    if isShow == true then
        local path = "Res/Widgets/MainScene/RefByScript/Utils/AreaGizmos.prefab"
        ResMgr:LoadAsync(path, function(asset)
            if not asset then
                return
            end
            if util.isNull(self.go_SceneRoot) == true then
                return
            end

            ---@type UnityEngine.GameObject
            local go = GameObject.Instantiate(asset, self.go_SceneRoot.transform)
            local isShow = CS.SROptionsData.IsShowTileMapEnable()
            -- 不显示区域边界线
            if isShow == false then
                self:DestroyAreaLineGizmos()
                return
            end

            self.MapGizmosView = go:GetComponent(typeof(LuaTarget)).Table
            self:ShowCameraGizmos()
            self:ShowAreaLineGizmos()
        end)
        return
    end

    -- 销毁
    self:ShowCameraGizmos()
    self:DestroyAreaLineGizmos()
end

return mapUnlockAreaMgr
