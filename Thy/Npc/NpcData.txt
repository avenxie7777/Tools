---@type NpcEvent
local NpcEvent = util.relativeRequire("NpcEvent")
local table_clear = table.clear
local table_insert = table.insert
local math_random = math.random
local math_floor = math.floor

---定义每个npc的行为和数据
---@class NpcData
---@field npcDataMgr MainSceneNpcModel 管理类引用
---@field npcId number
---@field npcType number npc类型
---@field MainSceneNpcType MainSceneNpcType npc类型定义
---@field curMoveAction NpcData.MoveAction 移动行为
---@field curMoveState NpcData.MoveState 移动状态
---@field curMoveEvent NpcData.MoveEvent 移动事件
---@field curTile TilePos 当前格子坐标
---@field tileUp TilePos 上面格子的格子坐标
---@field tileDown TilePos 下面格子的格子坐标
---@field tileLeft TilePos 左边格子的格子坐标
---@field tileRight TilePos 右边格子的格子坐标
---@field canMoveTileList TilePos[] 可以行走的格子列表
---@field newCanMoveTileList TilePos[] 没有走过的可以行走的格子列表
---@field curPos UnityEngine.Vector3 当前格子所处的世界坐标
---@field offsetY number y偏移
---@field moveDir NpcData.Direction 移动方向
---@field config MainSceneNpcConfig 配置数据
---@field npcDir number npc朝向【scaleX 1 和 -1，做镜像处理】
---@field moveTime number 移动时间
---@field curStopTime number 当前已停止的时间
---@field stopTime number 停止时间
---@field moveSpeedX number x移动速度
---@field moveSpeedY number y移动速度
---@field curMoveDistance number 当前移动距离
---@field halfPerTileSize UnityEngine.Vector3 单个格子的尺寸
---@field path table<number, boolean> 已经走过的路径
---@field npcView NpcView npcView实例
---@field index number 记数
---@field randomStopIndex number 一定移动行为后执行停止行为【随机下次停止的时机】
---@field isRoadFlag boolean 是否是路点
---@field curRoadStep number 当前已经走的路数
---@field totalRoadStep number 一次走的路数
---@field isPathFlag boolean 是否是路径点
---@field roadPathData MainSceneNpcPathData 路径点数据
---@field roadPathIndex number 路径的索引
---@field needChangeTargetPosInPath boolean 沿路径走时是否需要改变目标点
---@field roadPathTargetPos UnityEngine.Vector2 沿路径走时的目标点
---@field randomEventDuration number 每隔几帧后开始随机事件
---@field curEventDuration number 当前随机事件时间
---@field talkTime number 说话时间
---@field curTalkTime number 当前说话时间
---@field insideInScreen boolean 是否在屏幕内
---@field theSamePathCount boolean 相同路径计数
---@field enterBuildingBaseRate number 进入建筑的基础概率
---@field enterBuildingAddRate number 每次未进入建筑时增加的概率
---@field curEnterBuildingRate number 进入建筑当前概率
---@field enterBuildingLimitStep number 指定步数内不能进入建筑
---@field curEnterBuildingStep number 当前已走过的步数
---@field enterBuildingFlag boolean 是否是进入建筑标识
---@field isGoneNow boolean 是否正在消失中
---@field isOnlyMoveInRoad boolean 是否只在道路上行走
---@field statusAnim string 特殊状态下的npc动画
---@field EventNameEnum MainSceneNpcEventNameEnum 小人事件枚举
---@field insideInScreenOld boolean 记录旧的npc显示状态
---@field showPopup boolean 是否显示气泡
---@field posChangeData MainSceneNpcPosChangeData 坐标变化数据
---@field deltaTime number 帧时间
---@field speedRate number 速度倍率
local NpcData = Class()

---行走方向
---@private
NpcData.Direction = {
    Up = 1,
    Down = 2,
    Left = 3,
    Right = 4
}

---移动状态
---@private
NpcData.MoveState = {
    -- 无
    None = 1,
    -- 随机时间停止，一段时间后自己恢复行走
    RandomStop = 2,
    -- 无限期停止，根据状态切换成行走
    Stop = 3
}

---移动行为
---@private
NpcData.MoveAction = {
    -- 随机移动（默认行为）
    RandomMove = 1,
    -- 消失
    Gone = 2,
    -- 走路
    MoveInRoad = 3,
    -- 沿路径走
    MoveInPath = 4
}

---移动事件
---@private
NpcData.MoveEvent = {
    -- 说话
    Talk = 1,
    -- 显示指引图标
    GuideUI = 2
}

---Npc动画
---@private
NpcData.NpcAnimations = {
    -- 待机
    Stop = "1",
    -- 移动
    Move = "2",
    -- 战斗中
    Fighting = "3",
    -- 死亡
    Dead = "4"
}

---实例化NpcData对象
---@param npcData NpcData
---@param npcId number
---@param curTile TilePos 当前所处的tile坐标
---@param npcDataMgr MainSceneNpcModel 管理类引用
---@param isTest boolean 测试用
---@return NpcData
function NpcData.ctor(npcData, npcId, curTile, npcDataMgr, isTest)
    npcData.npcDataMgr = npcDataMgr
    npcData.npcId = npcId
    npcData.npcType = ModelFactory.MainSceneNpc:GetNpcType(npcId)
    npcData.MainSceneNpcType = ModelFactory.MainSceneNpc.NpcType
    npcData.EventNameEnum = ModelFactory.MainSceneNpc.EventNameEnum
    npcData.curTile = { x = curTile.x, y = curTile.y }
    npcData.path = {}
    npcData.tileUp = {}
    npcData.tileDown = {}
    npcData.tileLeft = {}
    npcData.tileRight = {}
    npcData.canMoveTileList = {}
    npcData.newCanMoveTileList = {}
    npcData.curPos = ModelFactory.TileMap:TilePos2TileWorldPos(npcData.curTile)
    npcData.offsetY = ModelFactory.MainSceneNpc:GetNpcOffsetPosY(npcId)
    npcData.curPos.y = npcData.curPos.y + npcData.offsetY
    npcData.config = ModelFactory.MainSceneNpc:GetMainSceneNpcConfig()
    npcData.moveDir = nil
    npcData.roadPathData = nil
    npcData.curMoveState = nil
    npcData.curMoveEvent = nil
    npcData.insideInScreenOld = nil
    npcData.npcDir = 1
    npcData.moveTime = math_floor(math_random(npcData.config.minMoveTime, npcData.config.maxMoveTime))
    npcData.curMoveDistance = 0
    npcData.curStopTime = 0
    npcData.randomEventDuration = math_random(100, 300)
    npcData.curEventDuration = 0
    npcData.index = 0
    npcData.theSamePathCount = 0
    npcData.randomStopIndex = math_floor(math_random(npcData.config.minStopSteps, npcData.config.maxStopSteps))
    npcData.enterBuildingBaseRate = npcData.config.enterBuildingBaseRate
    npcData.enterBuildingAddRate = npcData.config.enterBuildingAddRate
    npcData.enterBuildingLimitStep = npcData.config.enterBuildingLimitStep
    npcData.curEnterBuildingRate = npcData.config.enterBuildingBaseRate
    npcData.curEnterBuildingStep = 0
    npcData.curRoadStep = 0
    npcData.speedRate = 50
    npcData.totalRoadStep = math_floor(math_random(npcData.config.minRoadMoveSteps, npcData.config.maxRoadMoveSteps))
    npcData.isGoneNow = false
    npcData.showPopup = true
    -- 是否只在道路上行走【菜狗鸡精等特殊npc不能消失，所以只能在道路上行走，在道路上行走就不会出现无路可走的情况】
    npcData.isOnlyMoveInRoad = npcData.npcType == npcData.MainSceneNpcType.SaveGodNpc
    npcData.curMoveAction = npcData.isOnlyMoveInRoad == true and npcData.MoveAction.MoveInRoad or
        npcData.MoveAction.RandomMove
    local cellSize = ModelFactory.TileMap:GetCellSize()
    npcData.halfPerTileSize = { tonumber(cellSize.width) / 2, tonumber(cellSize.height) / 2 }

    -- 醉酒大仙要判断活动状态
    if npcData.npcType == npcData.MainSceneNpcType.SaveGodNpc then
        local status = ModelFactory.SaveGod:GetCurrentState()
        npcData:ChangeStatus(status)
    end

    -- 政策小人暂时不移动（三个小人在地图上跑会有问题）
    if npcData.npcType == npcData.MainSceneNpcType.PolicyNpc then
        npcData.curMoveState = npcData.MoveState.Stop
    end

    -- 测试用
    if isTest then
        local isPathFlag = ModelFactory.TileMap:IsPathFlagByTilePos(curTile)
        if isPathFlag then
            npcData.curMoveAction = npcData.MoveAction.MoveInPath
        end
    end
end

---强制停止，等待恢复
function NpcData:ForceStop()
    -- 修改spine动画
    if self.npcView then
        self.npcView:ChangeAnimation(self.NpcAnimations.Stop)
        self.npcView:SetOrderInLayer(self.curPos)
    end
end

---更新数据【整个游戏生命周期中，npc数据都在刷新】
---@param isShowPopup boolean 是否显示气泡
function NpcData:UpdateData(isShowPopup)
    self.showPopup = isShowPopup
    self:UpdateMoveState()
    self:UpdateMoveAction()
    -- 事件固定放在移动后【气泡需要位置信息】
    self:UpdateMoveEvent()
    ---更新显示状态，在屏幕外不显示
    self:UpdataShowState()
end

---NpcData与NpcView实例绑定
---@param npcView NpcView npcView实例
function NpcData:BindNpcView(npcView)
    self.npcView = npcView
    ModelFactory.MainSceneNpc:CheckBindNpcViewEvent(self.npcId)
end

---NpcData与NpcView实例解绑
function NpcData:UnbindNpcView()
    self.npcView = nil
    self.insideInScreenOld = nil
end

---通知销毁NpcView
function NpcData:DestroyNpcView()
    ModelFactory.MainSceneNpc:FireEvent(self.EventNameEnum.DestroyNpc, self.npcId)
end

---销毁npc指引器
function NpcData:DestroyMapGuideUIView()
    ModelFactory.MainSceneNpc:FireEvent(self.EventNameEnum.DestroyMapGuideUI, self.npcId)
end

---切换状态
---@param status number 状态
function NpcData:ChangeStatus(status)
    -- 活动开始
    if status == SaveGodState.Fight then
        self.curMoveState = self.MoveState.Stop
        self.statusAnim = self.NpcAnimations.Fighting
        return
    end

    -- 活动结束，boss未被击败
    if status == SaveGodState.Fail then
        self.curMoveState = self.MoveState.None
        return
    end

    -- 活动结束，boss被击败
    if status == SaveGodState.Success then
        self.curMoveState = self.MoveState.Stop
        self.statusAnim = self.NpcAnimations.Dead
        return
    end

    self.curMoveState = nil
    self.statusAnim = nil
end

---释放
function NpcData:Disposed()
    self.npcDataMgr = nil
    self.npcView = nil
    self.path = nil
    self.roadPathData = nil
    self.roadPathTargetPos = nil
    self.posChangeData = nil
    self.curTile = nil
    self.tileUp = nil
    self.tileDown = nil
    self.tileLeft = nil
    self.tileRight = nil
    self.halfPerTileSize = nil
    self.curPos = nil
    self.config = nil
    self.canMoveTileList = nil
    self.newCanMoveTileList = nil
    self.MainSceneNpcType = nil
    self.EventNameEnum = nil
end

---更新移动状态
---@private
function NpcData:UpdateMoveState()
    -- 已经有行为的情况下不刷新
    if self.curMoveState or self.isGoneNow then
        return
    end

    self.index = self.index + 1
    -- 停止
    if self.index >= self.randomStopIndex then
        self.randomStopIndex = math_floor(math_random(self.config.minStopSteps, self.config.maxStopSteps))
        self.index = 0
        self.curMoveState = self.MoveState.RandomStop
        return
    end

    -- 无【行走由MoveAction控制】
    self.curMoveState = self.MoveState.None
end

---更新移动行为
---@private
function NpcData:UpdateMoveAction()
    if self.isGoneNow then
        return
    end

    ------------------------------- 停止状态 -------------------------------
    -- 无期限停止
    if self.curMoveState == self.MoveState.Stop then
        self:DoStop()
        return
    end

    -- 随机时间停止
    if self.curMoveState == self.MoveState.RandomStop then
        self:DoRandomStop()
        return
    end

    ------------------------------- 行走状态 -------------------------------
    -- 走路逻辑
    if self.curMoveAction == self.MoveAction.MoveInRoad then
        self:DoMoveInRoad()
        return
    end

    -- 沿路线走逻辑
    if self.curMoveAction == self.MoveAction.MoveInPath then
        self:DoMoveInPath()
        return
    end

    -- 消失逻辑
    if self.curMoveAction == self.MoveAction.Gone then
        self:DoGone()
        return
    end

    -- 随机移动逻辑
    if self.curMoveAction == self.MoveAction.RandomMove then
        self:DoRandomMove()
        return
    end
end

---更新移动事件
---@private
function NpcData:UpdateMoveEvent()
    if self.isGoneNow then
        return
    end

    -- 没有事件的时候随机一个
    if not self.curMoveEvent then
        -- 菜狗鸡精和醉酒大仙等特殊npc显示指引图标
        if self.npcType == self.MainSceneNpcType.DogFoodNpc
            or self.npcType == self.MainSceneNpcType.SaveGodNpc
            or self.npcType == self.MainSceneNpcType.PolicyNpc then
            self.curMoveEvent = self.MoveEvent.GuideUI
            return
        end

        -- 以一定的频率随机
        self.curEventDuration = self.curEventDuration + 1
        if self.curEventDuration < self.randomEventDuration then
            return
        end

        self.curEventDuration = 0
        self.randomEventDuration = math_random(100, 300)
        -- 随机一个事件
        local randomCount = math_random(100)
        if randomCount <= 3 then
            self.curTalkTime = 0
            self.talkTime = 300
            self.curMoveEvent = self.MoveEvent.Talk
            return
        end
    end

    -- 显示指引图标
    if self.curMoveEvent == self.MoveEvent.GuideUI then
        self:ShowGuideUI()
        return
    end

    -- 说话
    if self.curMoveEvent == self.MoveEvent.Talk then
        if self.showPopup then
            self:DoTalk()
        else
            self:DestroyNpcPopupView()
        end
        return
    end
end

------------------------------------------------------- 停止逻辑 -------------------------------------------------------
---处理无限期停止
---@private
function NpcData:DoStop()
    -- 修改spine动画
    if self.npcView then
        self.statusAnim = self.statusAnim ~= nil and self.statusAnim or self.NpcAnimations.Stop
        self.npcView:ChangeAnimation(self.statusAnim)
        self.npcView:SetOrderInLayer(self.curPos)
    end
end

---处理随机时间停止
---@private
function NpcData:DoRandomStop()
    if not self.stopTime then
        self.stopTime = math_random(self.config.minStopTime, self.config.maxStopTime)
    end

    self.curStopTime = self.curStopTime + 1
    -- 时间到了，重置状态
    if self.curStopTime >= self.stopTime then
        self.curStopTime = 0
        self.stopTime = nil
        self.curMoveState = nil
    end

    -- 修改spine动画
    if self.npcView then
        self.npcView:ChangeAnimation(self.NpcAnimations.Stop)
        self.npcView:SetOrderInLayer(self.curPos)
    end
end

------------------------------------------------------- 消失逻辑 -------------------------------------------------------
---处理消失
---@private
function NpcData:DoGone()
    self.isGoneNow = true

    if not self.npcView then
        self:TriggerEvent(NpcEvent.Gone)
        return
    end

    -- 渐隐表现
    self.npcView:ChangeAnimation(self.NpcAnimations.Stop)
    self.npcView:DoGone(function()
        self:TriggerEvent(NpcEvent.Gone)
    end)
end

------------------------------------------------------- 走路逻辑 -------------------------------------------------------
---处理走路
---@private
function NpcData:DoMoveInRoad()
    -- 重新选取方向
    if not self.moveDir then
        self:GetMoveDirectionInRoad()
        -- 没有路点可走的话就切换成随机行走
        if self.curMoveAction == self.MoveAction.RandomMove then
            return
        end
        self.moveTime = math_random(self.config.minMoveTime, self.config.maxMoveTime)
        self.moveSpeedX = self.halfPerTileSize[1] / self.moveTime
        self.moveSpeedY = self.halfPerTileSize[2] / self.moveTime
    end

    self.deltaTime = UE.Time.deltaTime * self.speedRate

    -- 往上走
    if self.moveDir == self.Direction.Up then
        self.curPos.x = self.curPos.x - self.moveSpeedX * self.deltaTime
        self.curPos.y = self.curPos.y + self.moveSpeedY * self.deltaTime
        -- 往下走
    elseif self.moveDir == self.Direction.Down then
        self.curPos.x = self.curPos.x + self.moveSpeedX * self.deltaTime
        self.curPos.y = self.curPos.y - self.moveSpeedY * self.deltaTime
        -- 往左走
    elseif self.moveDir == self.Direction.Left then
        self.curPos.x = self.curPos.x - self.moveSpeedX * self.deltaTime
        self.curPos.y = self.curPos.y - self.moveSpeedY * self.deltaTime
        -- 往右走
    elseif self.moveDir == self.Direction.Right then
        self.curPos.x = self.curPos.x + self.moveSpeedX * self.deltaTime
        self.curPos.y = self.curPos.y + self.moveSpeedY * self.deltaTime
    end

    self.curMoveDistance = self.curMoveDistance + self.moveSpeedX * self.deltaTime
    -- 到达目标位置后重置状态
    if self.curMoveDistance >= self.halfPerTileSize[1] then
        self.curMoveDistance = 0
        self.moveDir = nil
        self.curMoveState = nil
        -- 路全走完后才开始随机选
        self.curRoadStep = self.curRoadStep + 1
        if self.curRoadStep >= self.totalRoadStep then
            -- 检查当前格子是否有特殊行为
            self:CheckTileAction()
        end
    end

    -- npc移动
    if self.npcView then
        self.npcView:ChangeAnimation(self.NpcAnimations.Move)
        self.npcView:Move(self.curPos, self.npcDir)
        self.npcView:SetOrderInLayer(self.curPos)
    end
end

---获取下个路点的行走方向
---@private
function NpcData:GetMoveDirectionInRoad()
    -- 获取周围所有格子坐标
    self.tileUp.x = self.curTile.x
    self.tileUp.y = self.curTile.y + 1
    self.tileDown.x = self.curTile.x
    self.tileDown.y = self.curTile.y - 1
    self.tileLeft.x = self.curTile.x - 1
    self.tileLeft.y = self.curTile.y
    self.tileRight.x = self.curTile.x + 1
    self.tileRight.y = self.curTile.y
    table_clear(self.canMoveTileList)

    -- 判断上方的点能否移动
    local isRoadUp = ModelFactory.TileMap:IsRoadFlagByTilePos(self.tileUp)
    if isRoadUp then
        local canMoveUp = ModelFactory.TileMap:CanMoveByTilePos(self.tileUp)
        if canMoveUp then
            self.moveDir = self.Direction.Up
            table_insert(self.canMoveTileList, self.tileUp)
        end
    end

    -- 判断下方的点能否移动
    local isRoadDown = ModelFactory.TileMap:IsRoadFlagByTilePos(self.tileDown)
    if isRoadDown then
        local canMoveDown = ModelFactory.TileMap:CanMoveByTilePos(self.tileDown)
        if canMoveDown then
            self.moveDir = self.Direction.Down
            table_insert(self.canMoveTileList, self.tileDown)
        end
    end

    -- 判断左边的点能否移动
    local isRoadLeft = ModelFactory.TileMap:IsRoadFlagByTilePos(self.tileLeft)
    if isRoadLeft then
        local canMoveLeft = ModelFactory.TileMap:CanMoveByTilePos(self.tileLeft)
        if canMoveLeft then
            self.moveDir = self.Direction.Left
            table_insert(self.canMoveTileList, self.tileLeft)
        end
    end

    -- 判断右边的点能否移动
    local isRoadRight = ModelFactory.TileMap:IsRoadFlagByTilePos(self.tileRight)
    if isRoadRight then
        local canMoveRight = ModelFactory.TileMap:CanMoveByTilePos(self.tileRight)
        if canMoveRight then
            self.moveDir = self.Direction.Right
            table_insert(self.canMoveTileList, self.tileRight)
        end
    end

    -- 无路可走
    if #self.canMoveTileList == 0 then
        self.curMoveAction = self.MoveAction.RandomMove
        return
    end

    -- 获取移动方向
    self:GetMoveDirection()
end

------------------------------------------------------- 沿路径走的逻辑 -------------------------------------------------------
---处理指定路径
---@private
function NpcData:DoMoveInPath()
    -- 获取路径数据
    if not self.roadPathData then
        local paths = ModelFactory.MainSceneNpc:GetPathData(self.curTile)
        if not paths or #paths <= 0 then
            self.curMoveAction = self.MoveAction.RandomMove
            return
        end

        local index = math_floor(math_random(#paths))
        self.roadPathData = paths[index]

        -- 判断目标点是否可走
        local finPos = self.roadPathData.paths[#self.roadPathData.paths]
        local finTile = ModelFactory.TileMap:TileWorldPos2TilePos(finPos)
        local canMove = ModelFactory.TileMap:CanMoveByTilePos(finTile)
        if canMove == false then
            self.curMoveAction = self.MoveAction.RandomMove
            self.roadPathData = nil
            return
        end

        self.roadPathIndex = 1
        self.needChangeTargetPosInPath = true
    end

    -- 改变目标点
    if self.needChangeTargetPosInPath then
        self.needChangeTargetPosInPath = false
        -- 获取目标点
        self.roadPathTargetPos = self.roadPathData.paths[self.roadPathIndex]
        self.moveTime = self.roadPathData.moveTime
        self.moveSpeedX = (self.roadPathTargetPos.x - self.curPos.x) / self.moveTime
        self.moveSpeedY = (self.roadPathTargetPos.y - self.curPos.y) / self.moveTime
        -- 方向
        self.npcDir = self.roadPathTargetPos.x >= self.curPos.x and -1 or 1
    end

    self.deltaTime = UE.Time.deltaTime * self.speedRate
    self.curPos.x = self.curPos.x + self.moveSpeedX * self.deltaTime
    self.curPos.y = self.curPos.y + self.moveSpeedY * self.deltaTime

    -- 到达一个路径点
    if self.npcDir == -1 then
        if self.curPos.x >= self.roadPathTargetPos.x then
            self.needChangeTargetPosInPath = true
            self.roadPathIndex = self.roadPathIndex + 1
            self.curPos.x = self.roadPathTargetPos.x
            self.curPos.y = self.roadPathTargetPos.y
        end
    else
        if self.curPos.x <= self.roadPathTargetPos.x then
            self.needChangeTargetPosInPath = true
            self.roadPathIndex = self.roadPathIndex + 1
            self.curPos.x = self.roadPathTargetPos.x
            self.curPos.y = self.roadPathTargetPos.y
        end
    end

    -- npc移动
    if self.npcView then
        self.npcView:ChangeAnimation(self.NpcAnimations.Move)
        self.npcView:Move(self.curPos, self.npcDir)
        self.npcView:SetOrderInLayer(self.curPos)
    end

    -- 沿路走行为结束
    if self.roadPathIndex > #self.roadPathData.paths then
        self.curTile = ModelFactory.TileMap:TileWorldPos2TilePos(self.curPos)
        self.roadPathData = nil
        -- 检查当前格子是否有特殊行为
        self:CheckTileAction()
    end
end

------------------------------------------------------- 随机移动逻辑 -------------------------------------------------------
---处理移动
---@private
function NpcData:DoRandomMove()
    -- 重新选取方向
    if not self.moveDir then
        self:GetRandomMoveDirection()
        -- 获取方向的时候无路可走就会触发消失逻辑
        if self.isGoneNow then
            return
        end
        self.moveTime = math_random(self.config.minMoveTime, self.config.maxMoveTime)
        self.moveSpeedX = self.halfPerTileSize[1] / self.moveTime
        self.moveSpeedY = self.halfPerTileSize[2] / self.moveTime
    end

    self.deltaTime = UE.Time.deltaTime * self.speedRate

    -- 往上走
    if self.moveDir == self.Direction.Up then
        self.curPos.x = self.curPos.x - self.moveSpeedX * self.deltaTime
        self.curPos.y = self.curPos.y + self.moveSpeedY * self.deltaTime
        -- 往下走
    elseif self.moveDir == self.Direction.Down then
        self.curPos.x = self.curPos.x + self.moveSpeedX * self.deltaTime
        self.curPos.y = self.curPos.y - self.moveSpeedY * self.deltaTime
        -- 往左走
    elseif self.moveDir == self.Direction.Left then
        self.curPos.x = self.curPos.x - self.moveSpeedX * self.deltaTime
        self.curPos.y = self.curPos.y - self.moveSpeedY * self.deltaTime
        -- 往右走
    elseif self.moveDir == self.Direction.Right then
        self.curPos.x = self.curPos.x + self.moveSpeedX * self.deltaTime
        self.curPos.y = self.curPos.y + self.moveSpeedY * self.deltaTime
    end

    self.curMoveDistance = self.curMoveDistance + self.moveSpeedX * self.deltaTime
    -- 到达目标位置后重置状态
    if self.curMoveDistance >= self.halfPerTileSize[1] then
        self.curMoveDistance = 0
        self.moveDir = nil
        self.curMoveState = nil
        -- 检查当前格子是否有特殊行为
        self:CheckTileAction()
    end

    -- npc移动
    if self.npcView then
        self.npcView:ChangeAnimation(self.NpcAnimations.Move)
        self.npcView:Move(self.curPos, self.npcDir)
        self.npcView:SetOrderInLayer(self.curPos)
    end
end

---获取行走方向
---@private
function NpcData:GetRandomMoveDirection()
    -- 获取周围所有格子坐标
    self.tileUp.x = self.curTile.x
    self.tileUp.y = self.curTile.y + 1
    self.tileDown.x = self.curTile.x
    self.tileDown.y = self.curTile.y - 1
    self.tileLeft.x = self.curTile.x - 1
    self.tileLeft.y = self.curTile.y
    self.tileRight.x = self.curTile.x + 1
    self.tileRight.y = self.curTile.y
    table_clear(self.canMoveTileList)

    -- 判断上方的点能否移动
    local canMoveUp = ModelFactory.TileMap:CanMoveByTilePos(self.tileUp)
    if canMoveUp then
        self.moveDir = self.Direction.Up
        table_insert(self.canMoveTileList, self.tileUp)
    end

    -- 判断下方的点能否移动
    local canMoveDown = ModelFactory.TileMap:CanMoveByTilePos(self.tileDown)
    if canMoveDown then
        self.moveDir = self.Direction.Down
        table_insert(self.canMoveTileList, self.tileDown)
    end

    -- 判断左边的点能否移动
    local canMoveLeft = ModelFactory.TileMap:CanMoveByTilePos(self.tileLeft)
    if canMoveLeft then
        self.moveDir = self.Direction.Left
        table_insert(self.canMoveTileList, self.tileLeft)
    end

    -- 判断右边的点能否移动
    local canMoveRight = ModelFactory.TileMap:CanMoveByTilePos(self.tileRight)
    if canMoveRight then
        self.moveDir = self.Direction.Right
        table_insert(self.canMoveTileList, self.tileRight)
    end

    -- 无路可走
    if #self.canMoveTileList == 0 then
        self:DoGone()
        return
    end

    -- 获取移动方向
    self:GetMoveDirection()
end

------------------------------------------------------- 指引逻辑 -------------------------------------------------------
---显示指引图标
---@private
function NpcData:ShowGuideUI()
    if not self.npcDataMgr then
        return
    end

    -- 政策小人不会移动，所以不用发送事件
    if self.npcType == self.MainSceneNpcType.PolicyNpc then
        return
    end

    if not self.posChangeData then
        ---@type MainSceneNpcPosChangeData
        self.posChangeData = {}
        self.posChangeData.npcType = self.npcType
    end

    self.posChangeData.pos = self.curPos
    self.npcDataMgr:AddNpcPosChangeData(self.posChangeData)
end

------------------------------------------------------- 说话逻辑 -------------------------------------------------------
---npc说话
---@private
function NpcData:DoTalk()
    self.curTalkTime = self.curTalkTime + 1
    self:UpdataPopupState()
    -- 说话结束
    if self.curTalkTime >= self.talkTime then
        self:DestroyNpcPopupView()
    end
end

---更新显示状态，在屏幕外不显示气泡
---@private
function NpcData:UpdataPopupState()
    if not self.npcView then
        return
    end
    self.npcView:UpdatePopup(self.insideInScreen)
end

---销毁npc气泡
---@private
function NpcData:DestroyNpcPopupView()
    if self.npcView then
        self.npcView:DestroyPopup()
    end
    ModelFactory.MainSceneNpc:ClearMsgForTalk(self.npcId)
    self.curMoveEvent = nil
end

------------------------------------------------------- 辅助类 -------------------------------------------------------
---触发事件
---@param npcEvent NpcEvent
---@private
function NpcData:TriggerEvent(npcEvent)
    if not self.npcDataMgr then
        return
    end

    self.npcDataMgr:TriggerEvent(self.npcId, npcEvent, self.npcType == self.MainSceneNpcType.SaveGodNpc)
end

---更新显示状态，在屏幕外不显示
---@private
function NpcData:UpdataShowState()
    if self.isGoneNow or not self.npcDataMgr or not self.npcDataMgr:GetMapActive() then
        return
    end

    local minX, maxX, minY, maxY = self.npcDataMgr:GetCameraShownData()

    if not minX then
        return
    end

    local isAlwaysShow = self.npcDataMgr:GetFullScreenShotFlag()
    self.insideInScreen = true

    -- 需要做视野判断
    if not isAlwaysShow then
        -- 当前x坐标小于minX
        if self.curPos.x < minX then
            self.insideInScreen = false
            -- 当前x坐标大于maxX
        elseif self.curPos.x > maxX then
            self.insideInScreen = false
            -- 当前y坐标小于minY
        elseif self.curPos.y < minY then
            self.insideInScreen = false
            -- 当前y坐标大于maxY
        elseif self.curPos.y > maxY then
            self.insideInScreen = false
        end
    end

    if self.insideInScreenOld == nil or self.insideInScreen ~= self.insideInScreenOld then
        self.insideInScreenOld = self.insideInScreen
        self.npcDataMgr:AddNpcShownStateData(self.npcId, self.insideInScreen)
    end
end

---获取移动方向
---@private
function NpcData:GetMoveDirection()
    local count = #self.canMoveTileList
    -- 只有一个格子能走时不需要再判断有没有走过
    if count == 1 then
        if self.moveDir == self.Direction.Up then
            self.curTile.x = self.tileUp.x
            self.curTile.y = self.tileUp.y
            self.npcDir = 1
        elseif self.moveDir == self.Direction.Down then
            self.curTile.x = self.tileDown.x
            self.curTile.y = self.tileDown.y
            self.npcDir = -1
        elseif self.moveDir == self.Direction.Left then
            self.curTile.x = self.tileLeft.x
            self.curTile.y = self.tileLeft.y
            self.npcDir = 1
        else
            self.curTile.x = self.tileRight.x
            self.curTile.y = self.tileRight.y
            self.npcDir = -1
        end

        local key = ModelFactory.TileMap:GetKeyByTilePos(self.curTile)
        self.path[key] = true
        return
    end

    table_clear(self.newCanMoveTileList)
    -- 拥有多个可行走的点时，优先走没有走过的路
    for i = 1, count do
        local key = ModelFactory.TileMap:GetKeyByTilePos(self.canMoveTileList[i])
        if not self.path[key] then
            table_insert(self.newCanMoveTileList, self.canMoveTileList[i])
        end
    end

    ---@type TilePos
    local targetTilePos
    -- 有没有走过的新格子
    if #self.newCanMoveTileList > 0 then
        local index = math_random(#self.newCanMoveTileList)
        targetTilePos = self.newCanMoveTileList[index]
        self.theSamePathCount = 0
    else
        -- 全是走过的格子情况下，随机找一个格子
        local index = math_random(count)
        targetTilePos = self.canMoveTileList[index]
        -- 到达一定数量后清空路径
        self.theSamePathCount = self.theSamePathCount + 1
        if self.theSamePathCount >= 2 then
            self.theSamePathCount = 0
            table_clear(self.path)
        end
    end

    self.curTile.x = targetTilePos.x
    self.curTile.y = targetTilePos.y
    local key = ModelFactory.TileMap:GetKeyByTilePos(targetTilePos)
    self.path[key] = true
    if targetTilePos.x == self.tileUp.x and targetTilePos.y == self.tileUp.y then
        self.moveDir = self.Direction.Up
        self.npcDir = 1
    elseif targetTilePos.x == self.tileDown.x and targetTilePos.y == self.tileDown.y then
        self.moveDir = self.Direction.Down
        self.npcDir = -1
    elseif targetTilePos.x == self.tileLeft.x and targetTilePos.y == self.tileLeft.y then
        self.moveDir = self.Direction.Left
        self.npcDir = 1
    else
        self.moveDir = self.Direction.Right
        self.npcDir = -1
    end
    targetTilePos = nil
end

---检查格子标识，是否触发特殊行为
---@private
function NpcData:CheckTileAction()
    -- 判断是否是路点
    self.isRoadFlag = ModelFactory.TileMap:IsRoadFlagByTilePos(self.curTile)
    if self.isRoadFlag == true then
        local doRoad = math_random(10000) <= self.config.roadRate
        if doRoad == true then
            self.curMoveAction = self.MoveAction.MoveInRoad
            self.curRoadStep = 0
            self.totalRoadStep = math_floor(math_random(self.config.minRoadMoveSteps, self.config.maxRoadMoveSteps))
            return
        end
    end

    -- 判断是否是路径点
    self.isPathFlag = ModelFactory.TileMap:IsPathFlagByTilePos(self.curTile)
    if self.isPathFlag == true then
        local doPath = math_random(10000) <= self.config.pathRate
        if doPath == true then
            self.curMoveAction = self.MoveAction.MoveInPath
            return
        end
    end

    -- 只能在道路上行走
    if self.isOnlyMoveInRoad == true then
        -- 直接选择道路
        if self.isRoadFlag == true then
            self.curMoveAction = self.MoveAction.MoveInRoad
            self.curRoadStep = 0
            self.totalRoadStep = math_floor(math_random(self.config.minRoadMoveSteps, self.config.maxRoadMoveSteps))
            return
        end
    end

    -- 只有居民和隐士才需要进行进入建筑的判断
    if self.npcType == self.MainSceneNpcType.Villager or self.npcType == self.MainSceneNpcType.Hero then
        -- 一定步数后才能进行建筑点的判断
        self.curEnterBuildingStep = self.curEnterBuildingStep + 1
        if self.curEnterBuildingStep >= self.enterBuildingLimitStep then
            -- 判断是否是进入建筑点
            self.enterBuildingFlag = ModelFactory.TileMap:IsEnterPosInBuildings(self.curTile)
            if self.enterBuildingFlag then
                local doEnter = math_random(10000) <= self.curEnterBuildingRate
                if doEnter == true then
                    self.curEnterBuildingStep = 0
                    self.curEnterBuildingRate = self.enterBuildingBaseRate
                    self.curMoveAction = self.MoveAction.Gone
                    return
                end

                -- 没有进入则增加概率
                self.curEnterBuildingRate = self.curEnterBuildingRate + self.enterBuildingAddRate
            end
        end
    end

    -- 无特殊行为
    self.curMoveAction = self.MoveAction.RandomMove
end

return NpcData
